{"BLOG_INFO":{"author":"tencent-cloud-native","blogStats":{"buryCount":0,"diggCount":1,"feedbackCount":0,"postId":16355019,"viewCount":3294},"content":"<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n <h2 id=\"作者\">作者</h2>\n <p>尹烨，腾讯专家工程师， 腾讯云 TCM 产品负责人。在 K8s、Service Mesh 等方面有多年的实践经验。</p>\n <h2 id=\"导语\">导语</h2>\n <p>对于很多后端服务业务，我们都希望得到客户端源 IP。云上的负载均衡器，比如，腾讯云 CLB 支持将客户端源IP传递到后端服务。但在使用 istio 的时候，由于 istio ingressgateway 以及 sidecar 的存在，后端服务如果需要获取客户端源 IP，特别是四层协议，情况会变得比较复杂。</p>\n <h2 id=\"正文\">正文</h2>\n <p>很多业务场景，我们都希望得到客户端源 IP。云上负载均衡器，比如，腾讯云 <a href=\"https://cloud.tencent.com/document/product/214/3728\" title=\"CLB\" target=\"_blank\" rel=\"noopener nofollow\">CLB</a>支持将客户端 IP 传递到后端服务。<a href=\"https://cloud.tencent.com/document/product/1261/63044#.E5.88.9B.E5.BB.BA.E8.BE.B9.E7.BC.98.E4.BB.A3.E7.90.86.E7.BD.91.E5.85.B3\" title=\"TKE/TCM\" target=\"_blank\" rel=\"noopener nofollow\">TKE/TCM</a> 也对该能力做了很好的集成。</p>\n <p>但在使用 istio 的时候，由于中间链路上，istio ingressgateway 以及 sidecar 的存在，后端服务如果需要获取客户端 IP，特别是四层协议，情况会变得比较复杂。</p>\n <p><img src=\"https://qcloudimg.tencent-cloud.cn/raw/f6f47e972acfafe8d2d707c4666d8f73.jpg\" alt=\"\" loading=\"lazy\"></p>\n <p>对于应用服务来说，它只能看到 Envoy 过来的连接。</p>\n <h2 id=\"一些常见的源-ip-保持方法\">一些常见的源 IP 保持方法</h2>\n <p>先看看一些常见 Loadbalancer/Proxy 的源 IP 保持方法。我们的应用协议一般都是四层、或者七层协议。</p>\n <h3 id=\"七层协议的源-ip-保持\">七层协议的源 IP 保持</h3>\n <p>七层的客户端源 IP 保持方式比较简单，最具代表性的是 HTTP 头<code>XFF（X-Forwarded-For）</code>，XFF 保存原始客户端的源 IP，并透传到后端，应用可以解析 XFF 头，得到客户端的源 IP。常见的七层代理组件，比如 Nginx、Haproxy，包括 Envoy 都支持该功能。</p>\n <h3 id=\"四层协议的源-ip-保持\">四层协议的源 IP 保持</h3>\n <h4 id=\"dnat\">DNAT</h4>\n <p><code>IPVS/iptables</code>都支持 DNAT，客户端通过 VIP 访问 LB，请求报文到达 LB 时，LB 根据连接调度算法选择一个后端 Server，将报文的目标地址 VIP 改写成选定 Server 的地址，报文的目标端口改写成选定 Server 的相应端口，最后将修改后的报文发送给选出的 Server。由于 LB 在转发报文时，没有修改报文的源 IP，所以，后端 Server 可以看到客户端的源 IP。</p>\n <p><img src=\"https://qcloudimg.tencent-cloud.cn/raw/e8fdba9989e53078282a575d5bf8bc5e.png\" alt=\"\" loading=\"lazy\"></p>\n <h4 id=\"transparent-proxy\">Transparent Proxy</h4>\n <p><code>Nginx/Haproxy</code> 支持透明代理(<code>Transparent Proxy</code>)。当开启该配置时，LB 与后端服务建立连接时，会将 socket 的源 IP 绑定为客户端的 IP 地址，这里依赖内核<a href=\"https://www.kernel.org/doc/Documentation/networking/tproxy.rst\" title=\"TPROXY\" target=\"_blank\" rel=\"noopener nofollow\">TPROXY</a>以及 socket 的 <code>IP_TRANSPARENT</code> 选项。</p>\n <p>此外，上面两种方式，后端服务的响应必须经过 LB，再回到 Client，一般还需要策略路由的配合。</p>\n <h4 id=\"toa\">TOA</h4>\n <p>TOA(<code>TCP Option Address</code>)是基于四层协议（TCP）获取真实源 IP 的方法，本质是将源 IP 地址插入 TCP 协议的 Options 字段。这需要内核安装对应的<a href=\"https://github.com/Huawei/TCP_option_address\" title=\"TOA内核模块\" target=\"_blank\" rel=\"noopener nofollow\">TOA内核模块</a>。</p>\n <h4 id=\"proxy-protocol\">Proxy Protocol</h4>\n <p><a href=\"https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\" title=\"Proxy Protocol\" target=\"_blank\" rel=\"noopener nofollow\">Proxy Protocol</a>是 Haproxy 实现的一个四层源地址保留方案。它的原理特别简单，Proxy 在与后端 Server 建立 TCP 连接后，在发送实际应用数据之前，首先发送一个<code>Proxy Protocol</code>协议头(包括客户端源 IP/端口、目标IP/端口等信息)。这样，后端 server 通过解析协议头获取真实的客户端源 IP 地址。</p>\n <p><code>Proxy Protocol</code>需要 Proxy 和 Server 同时支持该协议。但它却可以实现跨多层中间代理保持源 IP。这有点类似七层 XFF 的设计思想。</p>\n <h2 id=\"istio-中实现源-ip-保持\">istio 中实现源 IP 保持</h2>\n <p>istio 中，由于 istio ingressgateway 以及 sidecar 的存在，应用要获取客户端源 IP 地址，会变得比较困难。但 Envoy 本身为了支持<a href=\"https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_features/ip_transparency\" title=\"透明代理\" target=\"_blank\" rel=\"noopener nofollow\">透明代理</a>，它支持<code>Proxy Protocol</code>，再结合 TPROXY，我们可以在 istio 的服务中获取到源 IP。</p>\n <h3 id=\"东西向流量\">东西向流量</h3>\n <p><img src=\"https://qcloudimg.tencent-cloud.cn/raw/89160f9530df436059f99c1a89895b09.png\" alt=\"\" loading=\"lazy\"></p>\n <p>istio 东西向服务访问时，由于 Sidecar 的注入，所有进出服务的流量均被 Envoy 拦截代理，然后再由 Envoy 将请求转给应用。所以，应用收到的请求的源地址，是 Envoy 访问过来的地址<code>127.0.0.6</code>。</p>\n <pre><code># kubectl -n foo apply -f samples/httpbin/httpbin.yaml\n# kubectl -n foo apply -f samples/sleep/sleep.yaml\n# kubectl -n foo get pods -o wide\nNAME                       READY   STATUS    RESTARTS   AGE    IP            NODE           NOMINATED NODE   READINESS GATES\nhttpbin-74fb669cc6-qvlb5   2/2     Running   0          4m9s   172.17.0.57   10.206.2.144   &lt;none&gt;           &lt;none&gt;\nsleep-74b7c4c84c-9nbtr     2/2     Running   0          6s     172.17.0.58   10.206.2.144   &lt;none&gt;           &lt;none&gt;\n\n\n# kubectl -n foo exec -it deploy/sleep -c sleep -- curl http://httpbin:8000/ip\n{\n  \"origin\": \"127.0.0.6\"\n}\n</code></pre>\n <p>可以看到，httpbin 看到的源 IP 是<code>127.0.0.6</code>。从 socket 信息，也可以确认这一点。</p>\n <pre><code># kubectl -n foo exec -it deploy/httpbin -c httpbin -- netstat -ntp | grep 80\ntcp        0      0 172.17.0.57:80          127.0.0.6:56043         TIME_WAIT   -\n</code></pre>\n <ul>\n  <li>istio 开启 TPROXY</li>\n </ul>\n <p>我们修改 httpbin deployment，使用 TPROXY（注意<code>httpbin</code>的 IP 变成了<code>172.17.0.59</code>）:</p>\n <pre><code># kubectl patch deployment -n foo httpbin -p '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"sidecar.istio.io/interceptionMode\":\"TPROXY\"}}}}}'\n# kubectl -n foo get pods -l app=httpbin  -o wide\nNAME                       READY   STATUS    RESTARTS   AGE   IP            NODE           NOMINATED NODE   READINESS GATES\nhttpbin-6565f59ff8-plnn7   2/2     Running   0          43m   172.17.0.59   10.206.2.144   &lt;none&gt;           &lt;none&gt;\n\n# kubectl -n foo exec -it deploy/sleep -c sleep -- curl http://httpbin:8000/ip\n{\n  \"origin\": \"172.17.0.58\"\n}\n</code></pre>\n <p>可以看到，httpbin 可以得到 sleep 端的真实 IP。</p>\n <p><img src=\"https://qcloudimg.tencent-cloud.cn/raw/f30a248169f78b86fc6de01af7657a19.png\" alt=\"\" loading=\"lazy\"></p>\n <p>socket 的状态：</p>\n <pre><code># kubectl -n foo exec -it deploy/httpbin -c httpbin -- netstat -ntp | grep 80                  \ntcp        0      0 172.17.0.59:80          172.17.0.58:35899       ESTABLISHED 9/python3           \ntcp        0      0 172.17.0.58:35899       172.17.0.59:80          ESTABLISHED -\n</code></pre>\n <p>第一行是 httpbin 的接收端 socket，第二行是 envoy 的发送端 socket。</p>\n <p><code>httpbin envoy</code>日志：</p>\n <pre><code class=\"language-json\">{\"bytes_received\":0,\"upstream_local_address\":\"172.17.0.58:35899\",\n\"downstream_remote_address\":\"172.17.0.58:46864\",\"x_forwarded_for\":null,\n\"path\":\"/ip\",\"istio_policy_status\":null,\n\"response_code\":200,\"upstream_service_time\":\"1\",\n\"authority\":\"httpbin:8000\",\"start_time\":\"2022-05-30T02:09:13.892Z\",\n\"downstream_local_address\":\"172.17.0.59:80\",\"user_agent\":\"curl/7.81.0-DEV\",\"response_flags\":\"-\",\n\"upstream_transport_failure_reason\":null,\"request_id\":\"2b2ab6cc-78da-95c0-b278-5b3e30b514a0\",\n\"protocol\":\"HTTP/1.1\",\"requested_server_name\":null,\"duration\":1,\"bytes_sent\":30,\"route_name\":\"default\",\n\"upstream_cluster\":\"inbound|80||\",\"upstream_host\":\"172.17.0.59:80\",\"method\":\"GET\"}\n</code></pre>\n <p>可以看到，</p>\n <ul>\n  <li>downstream_remote_address: 172.17.0.58:46864 ## sleep的地址</li>\n  <li>downstream_local_address: 172.17.0.59:80 ## sleep访问的目标地址</li>\n  <li>upstream_local_address: 172.17.0.58:35899 ## httpbin envoy连接httpbin的local address(为sleep的IP)</li>\n  <li>upstream_host: 172.17.0.59:80 ## httpbin envoy访问的目标地址</li>\n </ul>\n <p>httpbin envoy 连接 httpbin 的 local address 为 sleep 的 IP 地址。</p>\n <h3 id=\"南北向流量\">南北向流量</h3>\n <p>对于南北向流量，客户端先请求 CLB，CLB 将请求转给 ingressgateway，再转到后端服务，由于中间多了 ingressgateway 一跳，想要获取客户端源 IP，变得更加困难。</p>\n <p>我们以 TCP 协议访问 httpbin:</p>\n <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: httpbin\n  namespace: foo\n  labels:\n    app: httpbin\n    service: httpbin\nspec:\n  ports:\n  - name: tcp\n    port: 8000\n    targetPort: 80\n  selector:\n    app: httpbin\n---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: httpbin-gw\n  namespace: foo\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 8000\n      name: tcp\n      protocol: TCP\n    hosts:\n    - \"*\"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: httpbin\n  namespace: foo\nspec:\n  hosts:\n    - \"*\"\n  gateways:\n    - httpbin-gw\n  tcp:\n    - match:\n      - port: 8000\n      route:\n        - destination:\n            port:\n              number: 8000\n            host: httpbin\n</code></pre>\n <p>通过 ingressgateway 访问 httpbin：</p>\n <pre><code># export GATEWAY_URL=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\n# curl http://$GATEWAY_URL:8000/ip\n{\n  \"origin\": \"172.17.0.54\"\n}\n</code></pre>\n <p>可以看到，httpbin 看到的地址是<code>ingressgateway</code>的地址：</p>\n <pre><code># kubectl -n istio-system get pods -l istio=ingressgateway -o wide\nNAME                                    READY   STATUS    RESTARTS   AGE     IP            NODE           NOMINATED NODE   READINESS GATES\nistio-ingressgateway-5d5b776b7b-pxc2g   1/1     Running   0          3d15h   172.17.0.54   10.206.2.144   &lt;none&gt;           &lt;none&gt;\n</code></pre>\n <p>虽然我们在<code>httpbin envoy</code>开启了透明代理，但 ingressgateway 并不能把 client 的源地址传到<code>httpbin envoy</code>。基于 envoy 实现的<code>Proxy Protocol</code>，可以解决这个问题。</p>\n <p>通过 EnvoyFilter 在 ingressgateway 和 httpbin 同时开启<code>Proxy Protocol</code>支持。</p>\n <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: ingressgw-pp\n  namespace: istio-system\nspec:\n  configPatches:\n  - applyTo: CLUSTER\n    patch:\n      operation: MERGE\n      value:\n        transport_socket:\n          name: envoy.transport_sockets.upstream_proxy_protocol\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.proxy_protocol.v3.ProxyProtocolUpstreamTransport\n            config:\n              version: V1\n            transport_socket:\n              name: \"envoy.transport_sockets.raw_buffer\"\n  workloadSelector:\n    labels:\n      istio: ingressgateway\n---\napiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: httpbin-pp\n  namespace: foo\nspec:\n  configPatches:\n  - applyTo: LISTENER\n    match:\n      context: SIDECAR_INBOUND\n    patch:\n      operation: MERGE\n      value:\n        listener_filters:\n        - name: envoy.filters.listener.proxy_protocol\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.filters.listener.proxy_protocol.v3.ProxyProtocol\n        - name: envoy.filters.listener.original_dst\n        - name: envoy.filters.listener.original_src\n  workloadSelector:\n    labels:\n      app: httpbin\n\n</code></pre>\n <p>再次通过 LB 访问 httpbin:</p>\n <pre><code># curl http://$GATEWAY_URL:8000/ip\n{\n  \"origin\": \"106.52.131.116\"\n}\n</code></pre>\n <p>httpbin 得到了客户端的源 IP。</p>\n <ul>\n  <li>ingressgateway envoy 日志</li>\n </ul>\n <pre><code>{\"istio_policy_status\":null,\"protocol\":null,\"bytes_sent\":262,\"downstream_remote_address\":\"106.52.131.116:6093\",\"start_time\":\"2022-05-30T03:33:33.759Z\",\n\"upstream_service_time\":null,\"authority\":null,\"requested_server_name\":null,\"user_agent\":null,\"request_id\":null,\n\"upstream_cluster\":\"outbound|8000||httpbin.foo.svc.cluster.local\",\"upstream_transport_failure_reason\":null,\"duration\":37,\"response_code\":0,\n\"method\":null,\"downstream_local_address\":\"172.17.0.54:8000\",\"route_name\":null,\"upstream_host\":\"172.17.0.59:80\",\"bytes_received\":83,\"path\":null,\n\"x_forwarded_for\":null,\"upstream_local_address\":\"172.17.0.54:36162\",\"response_flags\":\"-\"}\n</code></pre>\n <p>可以看到，</p>\n <ul>\n  <li><p>downstream_remote_address: 106.52.131.116:6093 ## 客户端源地址</p></li>\n  <li><p>downstream_local_address: 172.17.0.54:8000</p></li>\n  <li><p>upstream_local_address: 172.17.0.54:42122 ## ingressgw local addr</p></li>\n  <li><p>upstream_host: 172.17.0.59:80 ## httpbin 地址</p></li>\n </ul>\n <ul>\n  <li>httpbin envoy日志</li>\n </ul>\n <pre><code>{\"istio_policy_status\":null,\"response_flags\":\"-\",\"protocol\":null,\"method\":null,\"upstream_transport_failure_reason\":null,\"authority\":null,\"duration\":37,\n\"x_forwarded_for\":null,\"user_agent\":null,\"downstream_remote_address\":\"106.52.131.116:6093\",\"downstream_local_address\":\"172.17.0.59:80\",\n\"bytes_sent\":262,\"path\":null,\"requested_server_name\":null,\"upstream_service_time\":null,\"request_id\":null,\"bytes_received\":83,\"route_name\":null,\n\"upstream_local_address\":\"106.52.131.116:34431\",\"upstream_host\":\"172.17.0.59:80\",\"response_code\":0,\"start_time\":\"2022-05-30T03:33:33.759Z\",\"upstream_cluster\":\"inbound|80||\"}\n</code></pre>\n <p>可以看到，</p>\n <ul>\n  <li>downstream_remote_address: 106.52.131.116:6093 ## 客户端源地址</li>\n  <li>downstream_local_address: 172.17.0.59:80 ## httpbin地址</li>\n  <li>upstream_local_address: 106.52.131.116:34431 ## 保留了客户端IP，port不一样</li>\n  <li>upstream_host: 172.17.0.59:80 ## httpbin地址</li>\n </ul>\n <p>值得注意的是，<code>httpbin envoy</code>的<code>upstream_local_address</code>保留了客户端的 IP，这样，httpbin 看到的源地址 IP，就是客户端的真实 IP。</p>\n <ul>\n  <li>数据流</li>\n </ul>\n <p><img src=\"https://qcloudimg.tencent-cloud.cn/raw/62a08eb13404e890a8d8a9df872749ea.png\" alt=\"\" loading=\"lazy\"></p>\n <h2 id=\"相关实现分析\">相关实现分析</h2>\n <h3 id=\"trpoxy\">TRPOXY</h3>\n <p>TPROXY 的内核实现参考<a href=\"https://github.com/torvalds/linux/blob/master/net/netfilter/xt_TPROXY.c\" title=\"net/netfilter/xt_TPROXY.c\" target=\"_blank\" rel=\"noopener nofollow\">net/netfilter/xt_TPROXY.c</a>。</p>\n <p><code>istio-iptables</code>会设置下面的 iptables 规则，给数据报文设置标记。</p>\n <pre><code>-A PREROUTING -p tcp -j ISTIO_INBOUND\n-A PREROUTING -p tcp -m mark --mark 0x539 -j CONNMARK --save-mark --nfmask 0xffffffff --ctmask 0xffffffff\n-A OUTPUT -p tcp -m connmark --mark 0x539 -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\n-A ISTIO_DIVERT -j MARK --set-xmark 0x539/0xffffffff\n-A ISTIO_DIVERT -j ACCEPT\n-A ISTIO_INBOUND -p tcp -m conntrack --ctstate RELATED,ESTABLISHED -j ISTIO_DIVERT\n-A ISTIO_INBOUND -p tcp -j ISTIO_TPROXY\n-A ISTIO_TPROXY ! -d 127.0.0.1/32 -p tcp -j TPROXY --on-port 15006 --on-ip 0.0.0.0 --tproxy-mark 0x539/0xffffffff\n</code></pre>\n <p>值得一提的是，TPROXY 不用依赖 NAT，本身就可以实现数据包的重定向。另外，结合策略路由，将非本地的数据包通过本地 lo 路由:</p>\n <pre><code># ip rule list\n0:\tfrom all lookup local \n32765:\tfrom all fwmark 0x539 lookup 133 \n32766:\tfrom all lookup main \n32767:\tfrom all lookup default \n\n# ip route show table 133\nlocal default dev lo scope host\n</code></pre>\n <p>TPROXY 的更多详细介绍参考<a href=\"https://www.kernel.org/doc/Documentation/networking/tproxy.rst\" title=\"这里\" target=\"_blank\" rel=\"noopener nofollow\">这里</a>。</p>\n <h3 id=\"envoy-中-proxy-protocol-的实现\">Envoy 中 Proxy Protocol 的实现</h3>\n <ul>\n  <li>proxy protocol header format</li>\n </ul>\n <p>这里使用了<code>Version 1(Human-readable header format)</code>，如下：</p>\n <pre><code>0000   50 52 4f 58 59 20 54 43 50 34 20 31 30 36 2e 35   PROXY TCP4 106.5\n0010   32 2e 31 33 31 2e 31 31 36 20 31 37 32 2e 31 37   2.131.116 172.17\n0020   2e 30 2e 35 34 20 36 30 39 33 20 38 30 30 30 0d   .0.54 6093 8000.\n0030   0a                                                .\n</code></pre>\n <p>可以看到，header 包括 client 和 ingressgateway 的<code>IP:PORT</code>信息。更加详细的介绍参考<a href=\"https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\" title=\"这里\" target=\"_blank\" rel=\"noopener nofollow\">这里</a>。</p>\n <ul>\n  <li>ProxyProtocolUpstreamTransport</li>\n </ul>\n <p>ingressgateway 作为发送端，使用<code>ProxyProtocolUpstreamTransport</code>，构建<code>Proxy Protocol</code>头部:</p>\n <pre><code>/// source/extensions/transport_sockets/proxy_protocol/proxy_protocol.cc\n\nvoid UpstreamProxyProtocolSocket::generateHeaderV1() {\n  // Default to local addresses (used if no downstream connection exists e.g. health checks)\n  auto src_addr = callbacks_-&gt;connection().addressProvider().localAddress(); \n  auto dst_addr = callbacks_-&gt;connection().addressProvider().remoteAddress();\n\n  if (options_ &amp;&amp; options_-&gt;proxyProtocolOptions().has_value()) {\n    const auto options = options_-&gt;proxyProtocolOptions().value();\n    src_addr = options.src_addr_;\n    dst_addr = options.dst_addr_;\n  }\n\n  Common::ProxyProtocol::generateV1Header(*src_addr-&gt;ip(), *dst_addr-&gt;ip(), header_buffer_);\n}\n</code></pre>\n <ul>\n  <li>envoy.filters.listener.proxy_protocol</li>\n </ul>\n <p><code>httpbin envoy</code>作为接收端，配置ListenerFilter(<code>envoy.filters.listener.proxy_protocol</code>)解析<code>Proxy Protocol</code>头部:</p>\n <pre><code>/// source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc\n\nReadOrParseState Filter::onReadWorker() {\n  Network::ConnectionSocket&amp; socket = cb_-&gt;socket(); /// ConnectionHandlerImpl::ActiveTcpSocket\n...\n  if (proxy_protocol_header_.has_value() &amp;&amp; !proxy_protocol_header_.value().local_command_) {\n...\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.addressProvider().localAddress()) { /// proxy protocol header: 172.17.0.54:8000\n      socket.addressProvider().restoreLocalAddress(proxy_protocol_header_.value().local_address_); /// =&gt; 172.17.0.54:8000\n    } /// Network::ConnectionSocket\n    socket.addressProvider().setRemoteAddress(proxy_protocol_header_.value().remote_address_); /// 修改downstream_remote_address为106.52.131.116\n  }\n\n  // Release the file event so that we do not interfere with the connection read events.\n  socket.ioHandle().resetFileEvents();\n  cb_-&gt;continueFilterChain(true); /// ConnectionHandlerImpl::ActiveTcpSocket\n  return ReadOrParseState::Done;\n}\n</code></pre>\n <p>这里值得注意的，<code>envoy.filters.listener.proxy_protocol</code>在解析<code>proxy protocol header</code>时，<code>local_address</code>为发送端的<code>dst_addr(172.17.0.54:8000)</code>，<code>remote_address</code>为发送端的<code>src_addr(106.52.131.116)</code>。顺序刚好反过来了。</p>\n <p>经过<code>proxy_protocol</code>的处理，连接的<code>downstream_remote_address</code>被修改为client的源地址。</p>\n <ul>\n  <li>envoy.filters.listener.original_src</li>\n </ul>\n <p>对于<code>sidecar.istio.io/interceptionMode: TPROXY</code>，<code>virtualInbound listener</code>会增加<code>envoy.filters.listener.original_src</code>:</p>\n <pre><code># istioctl -n foo pc listeners deploy/httpbin --port 15006 -o json\n[\n    {\n        \"name\": \"virtualInbound\",\n        \"address\": {\n            \"socketAddress\": {\n                \"address\": \"0.0.0.0\",\n                \"portValue\": 15006\n            }\n        },\n        \"filterChains\": [...],\n        \"listenerFilters\": [\n            {\n                \"name\": \"envoy.filters.listener.original_dst\",\n                \"typedConfig\": {\n                    \"@type\": \"type.googleapis.com/envoy.extensions.filters.listener.original_dst.v3.OriginalDst\"\n                }\n            },\n            {\n                \"name\": \"envoy.filters.listener.original_src\",\n                \"typedConfig\": {\n                    \"@type\": \"type.googleapis.com/envoy.extensions.filters.listener.original_src.v3.OriginalSrc\",\n                    \"mark\": 1337\n                }\n            }\n        ...\n        ]\n        \"listenerFiltersTimeout\": \"0s\",\n        \"continueOnListenerFiltersTimeout\": true,\n        \"transparent\": true,\n        \"trafficDirection\": \"INBOUND\",\n        \"accessLog\": [...]\n    }\n]\n</code></pre>\n <p><code>envoy.filters.listener.original_src</code>通过<code>tcp option</code>实现修改<code>upstream_local_address</code>为<code>downstream_remote_address</code>，实现透传client IP。</p>\n <pre><code>/// source/extensions/filters/listener/original_src/original_src.cc\n\nNetwork::FilterStatus OriginalSrcFilter::onAccept(Network::ListenerFilterCallbacks&amp; cb) {\n  auto&amp; socket = cb.socket(); /// ConnectionHandlerImpl::ActiveTcpSocket.socket()\n  auto address = socket.addressProvider().remoteAddress();   /// get downstream_remote_address\n  ASSERT(address);\n\n  ENVOY_LOG(debug,\n            \"Got a new connection in the original_src filter for address {}. Marking with {}\",\n            address-&gt;asString(), config_.mark());\n\n...\n  auto options_to_add =\n      Filters::Common::OriginalSrc::buildOriginalSrcOptions(std::move(address), config_.mark()); \n  socket.addOptions(std::move(options_to_add)); /// Network::Socket::Options\n  return Network::FilterStatus::Continue;\n}\n</code></pre>\n <ul>\n  <li>envoy.filters.listener.original_dst</li>\n </ul>\n <p>另外，<code>httbin envoy</code>作为 ingressgateway 的接收端，<code>virtualInbound listener</code>还配置了 ListenerFilter(<code>envoy.filters.listener.original_dst</code>)，来看看它的作用。</p>\n <pre><code>// source/extensions/filters/listener/original_dst/original_dst.cc\n\nNetwork::FilterStatus OriginalDstFilter::onAccept(Network::ListenerFilterCallbacks&amp; cb) {\n  ENVOY_LOG(debug, \"original_dst: New connection accepted\");\n  Network::ConnectionSocket&amp; socket = cb.socket();\n\n  if (socket.addressType() == Network::Address::Type::Ip) { /// socket SO_ORIGINAL_DST option\n    Network::Address::InstanceConstSharedPtr original_local_address = getOriginalDst(socket); /// origin dst address\n\n    // A listener that has the use_original_dst flag set to true can still receive\n    // connections that are NOT redirected using iptables. If a connection was not redirected,\n    // the address returned by getOriginalDst() matches the local address of the new socket.\n    // In this case the listener handles the connection directly and does not hand it off.\n    if (original_local_address) { /// change local address to origin dst address\n      // Restore the local address to the original one.\n      socket.addressProvider().restoreLocalAddress(original_local_address);\n    }\n  }\n\n  return Network::FilterStatus::Continue;\n}\n</code></pre>\n <p>对于 istio，由 iptable 截持原有 request，并转到15006(in request)，或者15001(out request)端口，所以，处理 request 的 socket 的<code>local address</code>，并不请求的<code>original dst address</code>。<code>original_dst</code> <code>ListenerFilter</code>负责将 socket 的 local address 改为<code>original dst address</code>。</p>\n <p>对于<code>virtualOutbound listener</code>，不会直接添加<code>envoy.filters.listener.original_dst</code>，而是将<code>use_original_dst</code>设置为 true，然后 envoy 会自动添加<code>envoy.filters.listener.original_dst</code>。同时，<code>virtualOutbound listener</code>会将请求，转给请求原目的地址关联的 listener 进行处理。</p>\n <p>对于<code>virtualInbound listener</code>，会直接添加<code>envoy.filters.listener.original_dst</code>。与<code>virtualOutbound listener</code>不同的是，它只是将地址改为<code>original dst address</code>，而不会将请求转给对应的 listener 处理（对于入请求，并不存在 dst address 的 listener）。实际上，对于入请求是由 FilterChain 完成处理。</p>\n <p>参考 istio 生成<code>virtualInbound listener</code>的代码:</p>\n <pre><code>// istio/istio/pilot/pkg/networking/core/v1alpha3/listener_builder.go\n\nfunc (lb *ListenerBuilder) aggregateVirtualInboundListener(passthroughInspectors map[int]enabledInspector) *ListenerBuilder {\n\t// Deprecated by envoyproxy. Replaced\n\t// 1. filter chains in this listener\n\t// 2. explicit original_dst listener filter\n\t// UseOriginalDst: proto.BoolTrue,\n\tlb.virtualInboundListener.UseOriginalDst = nil\n\tlb.virtualInboundListener.ListenerFilters = append(lb.virtualInboundListener.ListenerFilters,\n\t\txdsfilters.OriginalDestination, /// 添加envoy.filters.listener.original_dst\n\t)\n\tif lb.node.GetInterceptionMode() == model.InterceptionTproxy { /// TPROXY mode\n\t\tlb.virtualInboundListener.ListenerFilters =\n\t\t\tappend(lb.virtualInboundListener.ListenerFilters, xdsfilters.OriginalSrc)\n\t}\n...\n</code></pre>\n <h2 id=\"小结\">小结</h2>\n <p>基于 TPROXY 以及 Proxy Protocol，我们可以在 istio 中，实现四层协议的客户端源 IP 的保持。</p>\n <h2 id=\"参考\">参考</h2>\n <ul>\n  <li><a href=\"https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/\" title=\"istio doc: Configuring Gateway Network Topology\" target=\"_blank\" rel=\"noopener nofollow\">istio doc: Configuring Gateway Network Topology</a></li>\n  <li><a href=\"https://www.nginx.com/blog/ip-transparency-direct-server-return-nginx-plus-transparent-proxy/\" title=\"IP Transparency and Direct Server Return with NGINX and NGINX Plus as Transparent Proxy\" target=\"_blank\" rel=\"noopener nofollow\">IP Transparency and Direct Server Return with NGINX and NGINX Plus as Transparent Proxy</a></li>\n  <li><a href=\"https://www.kernel.org/doc/Documentation/networking/tproxy.rst\" title=\"Kernel doc: Transparent proxy support\" target=\"_blank\" rel=\"noopener nofollow\">Kernel doc: Transparent proxy support</a></li>\n  <li><a href=\"https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\" title=\"Haproxy doc: The PROXY protocol\" target=\"_blank\" rel=\"noopener nofollow\">Haproxy doc: The PROXY protocol</a></li>\n  <li><a href=\"https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_features/ip_transparency\" title=\"Envoy doc: IP Transparency\" target=\"_blank\" rel=\"noopener nofollow\">Envoy doc: IP Transparency</a></li>\n  <li><a href=\"https://zhuanlan.zhihu.com/p/359191530\" title=\"【IstioCon 2021】如何在Istio中进行源地址保持？\" target=\"_blank\" rel=\"noopener nofollow\">【IstioCon 2021】如何在Istio中进行源地址保持？</a></li>\n </ul>\n <h2 id=\"关于我们\">关于我们</h2>\n <p>更多关于云原生的案例和知识，可关注同名【腾讯云原生】公众号~</p>\n <h4 id=\"福利\">福利：</h4>\n <p>①公众号后台回复【手册】，可获得《腾讯云原生路线图手册》&amp;《腾讯云原生最佳实践》~</p>\n <p>②公众号后台回复【系列】，可获得《15个系列100+篇超实用云原生原创干货合集》，包含Kubernetes 降本增效、K8s 性能优化实践、最佳实践等系列。</p>\n <p>③公众号后台回复【白皮书】，可获得《腾讯云容器安全白皮书》&amp;《降本之源-云原生成本管理白皮书v1.0》</p>\n <p>④公众号后台回复【光速入门】，可获得腾讯云专家5万字精华教程，光速入门Prometheus和Grafana。</p>\n</div>","date":13663260000,"id":"16355019","tags":[],"title":"Istio 中实现客户端源 IP 的保持","url":"https://www.cnblogs.com/tencent-cloud-native/p/16355019.html"}}